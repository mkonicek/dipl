\documentclass[10pt,a4paper,oneside]{scrreprt}
\usepackage{mystyle}

\begin{document}

\hypersetup{
  pdftitle={Scala Refactoring},
  pdfauthor={Mirko Stocker},
  pdfkeywords={Scala Refactoring IDE Eclipse Thesis}
}

\begin{titlepage}
  
\enlargethispage{10cm}

\begin{center}
\includegraphics[width=\linewidth]{titlepage.pdf}
\end{center}

\end{titlepage}

\emptypage

\chapter*{Abstract}

\pagenumbering{roman}

Refactoring -- the technique to improve the internal structure of a program -- has become a widely adopted practice among software engineers, but manual refactoring is tedious and error prone. 

The Scala programming language is supported on all major Java development platforms, but most do not yet assist the programmer with automated refactoring tools. 

This project provides an IDE independent library to create automated refactorings for Scala. A refactoring is essentially a transformation of the abstract syntax tree. The library makes writing such transformations as simple as possible: combinators can be used to build complex transformations from basic ones. Deriving the concrete source code changes from these converted trees is handled transparently by the library.

Several refactorings have been implemented on top of the library, along with the integration into the Scala IDE for Eclipse: Rename, Extract Local, Extract Method, Inline Local and Organize Imports.

\emptypage

\chapter*{Management Summary}

In this thesis, we describe the development of a refactoring tool for the Scala programming language, conducted at the Institute for Software at the University of Applied Sciences Rapperswil. This master's thesis is a continuation of a previous term project by the same author.

\section*{Motivation}

Refactoring means to improve the internal structure of a program while keeping its external behavior. Improving a program's internal structure can be achieved in various ways: the names that are used internally can be changed to better reflect their functionality, or the code can be reorganized to make the program easier to extend, read, comprehend, and test. 

Refactoring does not have to be done with a specific tool, nor is it limited to a certain language or technology. Most integrated development environments support the developer with automated refactorings. Having such support reduces the time and therefore the hurdle to apply a refactoring; automation is also less error-prone than doing the same operations manually.

Scala is a modern programming language developed by Martin Odersky and his team at EPFL. Scala combines various aspects from object oriented and functional programming models. While it supports the developers with many powerful features, it is still fully compatible with code written in Java, allowing projects to mix Scala and Java.

Scala is an impressive language, but if it wants to become widely used in enterprises, it also needs to provide tools, including integrated development environments (IDEs). There already exist several Scala IDEs, but their refactoring support is still very limited.

\section*{Goals}

The primary goal of this thesis is to support Scala IDEs with automated refactoring tools. The refactoring functionality is offered in the form of a library, so it can be integrated into and shared among different IDEs and other tools that want to refactor Scala code. To demonstrate the implemented refactorings, the library has to be integrated into the Eclipse based Scala IDE. 

A second goal is to make the creation of new automated refactorings as simple as possible, to enable interested developers to implement their own refactorings. 

\section*{Results}

We have developed a library that builds on the Scala compiler and contains everything that is needed to create automated refactorings for Scala. The following refactorings have been implemented: 

\begin{description}
  \item[Rename] for all the names that are used in the source code.
  \item[Extract Method] to extract a selection of statements into a new method.
  \item[Extract Local] to introduce a new local variable for an existing expression.
  \item[Inline Local] to replace references to a local variable with its right hand side.
  \item[Organize Imports] to clean up the imported dependencies of a source file.
 \end{description}

These refactorings are all fully integrated into the Scala IDE for Eclipse, along with an online help that explains the usage of each refactoring.

To help new refactoring implementors getting started, this report documents not only the internals of the library but also the detailed implementation of the refactorings as well as how-tos and guides on how new refactorings can be written and integrated into IDEs or other tools.

The implemented refactorings are already part of the current development builds of the Scala IDE for Eclipse and have been presented at the first Scala conference -- Scala Days 2010 \cite{ScalaDaysRefactoring}.

\newpage

\chapter*{Declaration of Authorship}

I, Mirko Stocker, declare that this thesis and the work presented in it is my own, original work. All the sources I consulted and cited are clearly attributed. I have acknowledged all main sources of help.

\vspace{3cm}

\noindent Location, Date: \hspace{1cm} \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots \\

\vspace{1.5cm}

\noindent Signature: \hspace{1.77cm} \ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots\ldots

\emptypage

\newpage

\setcounter{tocdepth}{2}

\tableofcontents

\emptypage
\newpage
\pagenumbering{arabic}

\chapter{Introduction} \label{chapter:introduction}

The goal of this project is to provide Scala developers with automated refactoring tools. This master's thesis is a continuation of a foregoing term project (see \cite{ScalaRefactoring}) at the University of Applied Sciences Rapperswil, Switzerland. 

In this chapter, we will briefly introduce the Refactoring technique and the Scala programming language, as well as explain the goals and motivation of this thesis.

\section{Refactoring}

Refactoring of programs is a well established practice among professional software developers. In his 1992 PhD thesis \cite{OpdykeThesis}, William Opdyke defined refactoring as 

\begin{quotation}
a set of program restructuring operations (refactorings) that support the design, evolution and reuse of object-oriented application frameworks.
\end{quotation}

The breakthrough in industry started in 1999, when Martin Fowler and his colleagues published their popular book \textit{Refactoring: Improving the Design of Existing Code} \cite{FowlerRefactoring}, where refactoring is defined as 

\begin{quotation}
the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure.
\end{quotation} 

Today, refactoring has been absorbed by the programming mainstream, and is usually well integrated into the developer's work-flow and development environment. Developers use refactoring tools to keep their code maintainable by applying refactorings such as Rename to quickly change identifiers. In agile environments, where software is rapidly adapted to handle new requirements, performing refactorings regularly is essential to get reusable code and to keep up with the pace of change.

Refactoring as a technique does not mandate a tool nor depend on a specific programming language.

\section{Scala}

The Scala programming language \cite{ProgrammingScala}, developed by Martin Odersky and his team at EPFL, is a statically typed, compiled language that runs on the Java Virtual Machine (or on .NET alternatively \cite{ScalacNet}) and excels with its unique combination of object-oriented and functional programming concepts. Odersky also calls Scala a postfunctional language because it has been designed ``to make functional constructs, imperative constructs, and objects all play well together'' \cite{ScalaPostFunctional}. 

One of Scala's strengths is its seamless interoperability with Java on the class level: Scala classes can extend Java classes and vice-versa. Scala also does not ship with a large standard library but uses existing Java classes where it is sensible.

Scala provides all of Java's object-oriented features but does away with the not really object oriented ones like primitive data types and static class members. Scala also provides code reuse via traits; a kind of interface that may contain implementations.

From functional programming, Scala has absorbed functions as first class values and embraces the idea of immutability with various language constructs. Scala even supports lazy evaluation through call-by-name parameters and the \src{lazy} modifier for values. A combination from both object-oriented and functional worlds can be seen in Scala's ability to use pattern matching to deconstruct objects while still preserving encapsulation.

These were just a few examples of how Scala differs from other languages such as Java. One last feature worth mentioning is that in Scala, building your own abstractions and control structures is easy, which is the reason why it has been named the ``scalable language''. For a short introduction and a tutorial, see \cite{ScalaTutorial} and \cite{ScalaByExample}.

\section{Integrated Development Environments}

Many programmers, particularly of mainstream languages such as Java and C\#, use integrated development environments (IDE) to create their software. Notably the IDEs for the Java programming language excel with automated refactoring support; the screen-shots in \figref{figure:ide_refactorings} show two examples. If Scala wants to cater to those programmers and become a viable alternative in enterprises, it needs to offer IDE support that is as comfortable to use and as mature as the existing Java tooling is.

Scala is supported on the three main Java development platforms Eclipse \cite{EclipseScalaIDE}, IntelliJ IDEA \cite{IntelliJScalaIDE}, and NetBeans \cite{NetBeansJScalaIDE}, but with the exception of IntelliJ IDEA -- which offers a few refactorings -- support for automated refactoring does not yet exist. Although a study by Emerson~Murphy-Hill et al. among developers using Eclipse \cite{RefactoringStudy} indicates that many refactorings are not performed with the tool support but by hand, other automated refactorings like Rename, Move and Extract Method are used frequently.

\begin{figure}
 \centering
 \includegraphics[width=0.7\linewidth]{ide_refactorings.png}
 \caption{Automated refactoring in Java IDEs}
 \label{figure:ide_refactorings}
\end{figure}

\section{Thesis Goals}

The goal of this thesis is to support Scala IDEs with automated refactoring tools. It aims to provide a comprehensive catalog of refactorings and the necessary infrastructure to create new refactorings. To maximize the number of IDEs and other tools that can profit from the project, it will provide an IDE independent refactoring library that only depends on the Scala compiler. IDEs can then seamlessly integrate this library by providing the user interface and interaction.

As many IDEs today are written in Java, integrating a Scala library is no problem. Also, because the majority of Scala IDEs are completely open source (NetBeans, Eclipse), having a single refactoring library allows their developers to cooperate on an implementation, not fragmenting the already scarce resources any further. As a showcase, this project provides the integration into the Eclipse based Scala IDE \cite{EclipseScalaIDE}.

Writing an automated refactoring is no trivial task, several things have to be taken care of: one has to analyze the source code, create an appropriate representation (e.g. abstract or concrete syntax tree) of the program, transform it and turn it back into plain source code. 

The heart of a refactoring is the transformation or manipulation of the program representation; but often -- from our experience with refactoring tools for languages like Ruby \cite{RubyRefactoring}, C++ \cite{CdtOopsla}, and Groovy \cite{GroovyOopsla} -- the developer also has to provide the instructions how these manipulations affect the source code, or how the changes made to the AST are to be translated back into source code changes. This makes creating new refactorings unjustifiably more complex and is a high entry barrier for contributors. The Scala refactoring library tries to make creating new refactorings as simple as possible: code generation from the abstract syntax tree is completely transparent and needs almost no guidance from the refactoring writer.

Transformations of the program are based on the Scala compiler's own AST, and are written in a functional programming style that makes it possible to assemble complex transformations from simple ones using combinators.

To summarize, the Scala Refactoring project develops an IDE independent refactoring library that makes creating new refactorings as simple as possible.

\section{Contents of This Report}

\newcommand{\rref}[2]{\ref{#1} on pages~\pageref{#1}--\pageref{#2}}

This document is organized as follows: Chapter~\rref{chapter:refactoring-library}{end-chapter:refactoring-library} explains the concepts and implementation of the refactoring library. The details of the implemented refactorings are described in Chapter~\rref{chapter:implemented-refactorings}{end-chapter:implemented-refactorings}. How these refactorings can be integrated into an IDE or other tool is the topic of Chapter~\rref{chapter:tool-integration}{end-chapter:tool-integration}. How the implemented refactorings are tested is explained in Chapter~\rref{chapter:testing}{end-chapter:testing}. Chapter~\rref{chapter:outlook}{end-chapter:outlook} concludes this thesis with a review of the achievements and an outlook on further work.

The project environment is briefly explained in Appendix~\rref{chapter:project-environment}{end-chapter:project-environment}. The appendices also contain a user guide to the refactorings in Eclipse (Appendix~\rref{chapter:user-guide}{end-chapter:user-guide}), and a how-to introduction for developers that explains how a new refactoring can be created in Appendix~\rref{chapter:developer-how-to}{end-chapter:developer-how-to}. Developers that work with Scala's AST might also be interested in Appendix~\rref{chapter:scala-ast}{end-chapter:scala-ast}, where the specific trees of the AST are described. Appendix~\rref{chapter:advanced-scala-features}{end-chapter:advanced-scala-features} contains explanations of more advanced Scala features and is referenced where needed in this document. The source code of this thesis is released under the Scala license, which is printed in Appendix~ \vref{chapter:scala-license}

\section{Target Audience}

We assume that the reader knows the basic Scala concepts (if not, Scala by Example \cite{ScalaByExample} is a good starting point) and is able to read Scala source code. Whenever more advanced or possibly confusing concepts are used, a reference to Appendix~\ref{chapter:advanced-scala-features} will be provided.

Developers who want to use the library to transform Scala source code should start with Chapter~\vref{chapter:refactoring-library} on the library internals and Appendix~\rref{chapter:scala-ast}{end-chapter:scala-ast} to learn more about Scala's AST. 

To integrate the existing refactorings in a new tool, Chapter~\rref{chapter:tool-integration}{end-chapter:tool-integration} shows how this can be done with a made up editor and how the integration into the Scala IDE for Eclipse looks like.

For those wishing to implement new refactorings, the how-to in Appendix~\rref{chapter:developer-how-to}{end-chapter:developer-how-to} and Chapter~\rref{chapter:implemented-refactorings}{end-chapter:implemented-refactorings} on the implemented refactorings can serve as a starting point. How the new refactoring can be tested is explained in Chapter~\rref{chapter:testing}{end-chapter:testing}.

Users who wish to provide accurate bug reports should take a look at Chapter~\rref{chapter:testing}{end-chapter:testing} on testing to learn how a new test that points out a failure can be implemented.

\emptypage

\chapter{Refactoring Library} \label{chapter:refactoring-library}

\input{2_refactoring_library} \label{end-chapter:refactoring-library}

\emptypage

\chapter{Implemented Refactorings} \label{chapter:implemented-refactorings}

The previous chapter explained the internals of the Scala Refactoring library; in this chapter, we shall take a look at the refactorings that have so far been implemented on top of it. 

The three components of the refactoring library -- analysis, transformation, and source generation -- can be used independently from each other, but they also have dependencies expressed through self type annotations (see \vref{section:self-type-annotation}). 

The \src{Refactoring} trait combines the library with their dependencies and can be used as an entry point by library users.

\begin{lstlisting}
trait Refactoring extends 
  Selections with 
  TreeTransformations with 
  SilentTracing with 
  SourceGenerator with 
  PimpedTrees {
  %\ldots%
}
\end{lstlisting}

Performing a refactoring is not a single-step process: when the user invokes a refactoring, the first step is to check whether the refactoring can be applied -- for example, to perform a renaming, a name has to be selected. We call this the \textit{prepare} step. This step usually has a result, which is used in a configuration dialog to parameterize the refactoring. In our renaming example, this is the new name. Using the information from the preparation step and the configured parameters, the refactoring can then be \textit{performed}. This yields either a list of changes to be applied or it can also fail. See  \figref{figure:refactoring-sequence} for a visualization.

These steps are represented by the abstract class \src{MultiStageRefactoring}, which is subclassed by all concrete refactoring implementations:
\needspace{15\baselineskip}
\begin{lstlisting}
abstract class MultiStageRefactoring extends Refactoring {
  
  type PreparationResult
  
  case class PreparationError(cause: String)

  def prepare(s: Selection): Either[PreparationError, PreparationResult]

  type RefactoringParameters
  
  case class RefactoringError(cause: String)
  
  def perform(selection: Selection, prepared: PreparationResult, params: RefactoringParameters)
    : Either[RefactoringError, List[Change]]
}
\end{lstlisting}

The reason why the selection and the preparation results need to be passed to \src{perform} is to keep it stateless. This makes it much easier for an IDE to let the user go backwards and forwards in its wizard, testing different configurations.

The remainder of this chapter introduces each refactoring and explains the current implementation for the Eclipse Scala IDE with examples. 

\section{Rename}

Renaming is one of the most used refactorings among Eclipse using Java programmers (see \cite{RefactoringStudy}, \cite{RefactoringInEclipse}). Choosing good names is a very basic and yet important task for a programmer if he wants to write readable code. During the evolution of a program, the roles of the classes, methods and variables change. Having an automated refactoring for renaming considerably reduces the cost of keeping these names in sync with their functionality.

\subsection{Features}

This implementation supports renaming of all identifiers that occur in the program -- for example, local values and variables, method definitions and parameters, class fields, variable bindings in pattern matches, classes, objects, traits, packages, and types parameters.

The IDE implementation distinguishes between two different modes: inline renaming as shown in \figref{figure:rename-screenshot-1} and the traditional dialog based implementation in \figref{figure:rename-screenshot-2}. Inline renaming is implemented using Eclipse's linked mode user interface \cite{LinkedUI}.

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{rename_screenshot_1.png}
  \caption{The Rename refactoring in the inline mode: the selected name along with all references can be renamed without the need of a wizard and without previewing the changes.}
  \label{figure:rename-screenshot-1}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{rename_screenshot_2.png}
  \caption{A classical Rename refactoring: All occurrences of the selected name are changed across all files in the project.}
  \label{figure:rename-screenshot-2}
\end{figure}

Inline renaming is automatically chosen if the identifier that is renamed has only a local scope -- for example, a local variable. All names that can potentially be accessed from other compilation units in the program are renamed with the wizard and show a preview of the changes.

\subsection{Implementation Details}

From the refactoring developer's point of view, the Rename refactoring is quite different from other refactorings. Because renaming does not change the shape of the AST at all, the transformations and source generation steps are trivial -- or not even needed. On the other hand, having an accurate index is crucial. The inline rename refactoring uses the index to find the locations of the names and uses neither the source generator nor tree transformations.

The implementation of the non-inline mode looks as follows:

\begin{lstlisting}
val occurences = index.occurences(selectedTree.symbol) 
    
val isInTheIndex = filter {
  case t: Tree %$\Rightarrow$% occurences contains t 
}

val renameTree = transform {
  case t: ImportSelectorTree %$\Rightarrow$% 
    mkRenamedImportTree(t, newName)
  case s: SymTree %$\Rightarrow$% 
    mkRenamedSymTree(s, newName)
  case t: TypeTree %$\Rightarrow$% 
    mkRenamedTypeTree(t, newName, selectedTree.symbol)
}

val rename = topdown(isInTheIndex &> renameTree |> id)

val renamedTrees = occurences flatMap (rename(_))
\end{lstlisting}

The \src{renameTree} transformation handles different kinds of trees but delegates to the \src{TreeFactory} to create the renamed trees. The \src{rename} transformation traverses the trees and renames the trees that are in the index, or keeps the original trees otherwise. This transformation is then applied to all trees returned by the index.

Why do we have to traverse the trees, would it not suffice to call \src{occurrences flatMap (renameTree(\_))} directly? No, this will not work for recursive method calls, where the method definition also has a child tree that has to be renamed.

\subsection{Limitations}

There is currently one limitation with the Rename refactoring: named parameters will not be renamed because they are not represented in the AST.

\section{Organize Imports}

It can be debated whether Organize Imports really deserves the label Refactoring, because it does not change the structure of your code; but neither does the Rename refactoring. But Organize Imports is definitely useful, therefore we chose to include it in our refactorings.

During the lifetime of a compilation unit, external dependencies can change and new import statements are added and old ones are removed. Organize imports reorders and simplifies these statements.

\subsection{Features}

Organize Imports does not need a configuration; the current implementation performs these three steps:

\begin{description}
  \item[Sort] the statements alphabetically by their full name.
\begin{multicols}{2}
\begin{lstlisting}
import java.lang.{String, Object}
import java.io.File
import collection.mutable.ListBuffer
\end{lstlisting}
\begin{lstlisting}
import collection.mutable.ListBuffer
import java.io.File
import java.lang.{String, Object}
\end{lstlisting}
\end{multicols}

  \item[Collapse] multiple distinct imports from the same package into a single statement:
\begin{multicols}{2}
\begin{lstlisting}
import java.lang.String
import java.lang.Object
\end{lstlisting}
\begin{lstlisting}
import java.lang.{Object, String}

\end{lstlisting}
\end{multicols}

  \item[Simplify] the imports: when a wildcard imports the whole package content, individual imports from that package are removed, unless they contain renames:
\begin{multicols}{2}
\begin{lstlisting}
import java.io._
import java.lang._
import java.io.FileSet
import java.lang.{String %$\Rightarrow$% S}
\end{lstlisting}
\needspace{\baselineskip}
\begin{lstlisting}
import java.io._
import java.lang.{String %$\Rightarrow$% S, _}


\end{lstlisting}
\end{multicols}
\end{description}

\figref{figure:organize-screenshot-1} shows a screenshot of the refactoring in action.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{organize_screenshot_1.png}
  \caption{The Organize Imports refactoring: we can see that the imports that were scattered all over the file are now all at the top in alphabetic order. All superfluous statements are getting removed, and imports from the same package are collapsed.}
  \label{figure:organize-screenshot-1}
\end{figure}

\subsection{Limitations}

The current implementation has several limitations compared to its Java counterpart. The refactoring does not do any dependency analysis, imports that are missing are not added, and unneeded imports are not being removed by Organize Imports. And there are more features that could be added in future versions:

\paragraph{Save Action} In Eclipse, actions can be performed automatically when a file is saved. Enabling Organize Imports to automatically organize the imports might be useful.

\paragraph{Introduce Import} In Scala, just as in Java, members from other packages do not have to be imported, they can also be used with their fully qualified name. Organize Imports could be extended to replace these fully qualified names with an import statement. 

\paragraph{Expand Wildcards} Once the refactoring does analyze the actually needed dependencies of the compilation unit, the refactoring might also replace all wildcard imports with just the necessary imports. This would also match the JDT's current behavior.

\paragraph{Shorten Import Paths} In contrast to Java, packages in Scala can be nested (see Appendix~\vref{section:package-nesting}). Organize Imports could take advantage of this and shorten the imported names. For example, the following import on the left could be simplified to the one on the right:

\begin{multicols}{2}
\begin{lstlisting}
package scala.tools.refactoring
package common

import scala.tools.refactoring.analysis.Index
\end{lstlisting}
\needspace{\baselineskip}
\begin{lstlisting}
package scala.tools.refactoring
package common

import analysis.Index
\end{lstlisting}
\end{multicols}

\section{Extract Local}

Extract Local Variable, also known as \textit{Introduce Explaining Variable}, should according to Fowler \cite{FowlerRefactoring} be used whenever ``you have a complicated expression''; and the proposed fix is to 

\begin{quotation}
put the result of the expression, or parts of the expression, in a temporary variable with a name that explains the purpose.
\end{quotation}

In Scala, another reason why one would want to introduce new local variables is because existing Java debuggers are easier to use when one can step over single lines and examine the resulting values.

\subsection{Features}

From a selected expression, the Extract Local refactoring will create a new value in the enclosing scope and replace the selected expression with a reference to that value. Just as the rename refactoring in a local scope, Extract Local also uses Eclipse's linked mode to avoid distracting the user with dialogs (see \figref{figure:extract-local-screenshot-1} for a screenshot).

\begin{figure}
  \centering
  \includegraphics[width=0.55\linewidth]{extract_local_screenshot_1.png}
  \caption{The Extract Local refactoring also uses the linked mode, making extracting a local variable much faster than with a wizard.}
  \label{figure:extract-local-screenshot-1}
\end{figure}


The following listings show a few examples of the refactoring, on the left is the original code with the selection in gray, and on the right is the refactored code (line breaks were added by the author).

\begin{multicols}{2}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  val props = System.getProperties
  


  if(%\bluebox{props.get("os.name") == "Linux"}%) {
    println("We're on Linux!")
  } else
    println("We're not on Linux!")
}
\end{lstlisting}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  val props = System.getProperties
  val %\bluebox{isLinux}% = 
    props.get("os.name") == "Linux"
  
  if(%\bluebox{isLinux}%) {
    println("We're on Linux!")
  } else
    println("We're not on Linux!")
}
\end{lstlisting}
\end{multicols}

\needspace{5\baselineskip}
\begin{multicols}{2}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {

  println(%\bluebox{"We're on Linux!"}%)
} else
  println("We're not on Linux!")
\end{lstlisting}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  val %\bluebox{msg}% = "We're on Linux!"
  println(%\bluebox{msg}%)
} else
  println("We're not on Linux!")
\end{lstlisting}
\end{multicols}

A more interesting examples shows what happens if there are no curly braces around the scope:

\begin{multicols}{2}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  println("We're on Linux!")
} else

  println(%\bluebox{"We're not on Linux!"}%)

\end{lstlisting}
\begin{lstlisting}
if(props.get("os.name") == "Linux") {
  println("We're on Linux!")
} else {
  val %\bluebox{msg}% = "We're not on Linux!"
  println(%\bluebox{msg}%)
}
\end{lstlisting}
\end{multicols}

We can extract all kinds of expressions -- for example, a part of a chain of expressions:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)

%\bluebox{l filter (\_ \% 2 == 0)}% mkString ", "
\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
val %\bluebox{filtered}% = l filter (_ %\%% 2 == 0)
%\bluebox{filtered}% mkString ", "
\end{lstlisting}
\end{multicols}

In the examples so far, we have only extracted expressions that resulted in a non-function value. Extract Local also lets you extract a method, which is turned into a partially applied function:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)
%\bluebox{l filter}% (_ %\%% 2 == 0) mkString ", "

\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
val %\bluebox{filterList}% = l filter _
%\bluebox{filterList}%(_ %\%% 2 == 0) mkString ", "
\end{lstlisting}
\end{multicols}

In the last example, we show how the extraction behaves inside single-expression functions:

\begin{multicols}{2}
\begin{lstlisting}
val l = List(1,2,3)
l filter (i %$\Rightarrow$% %\bluebox{i \% 2}% == 0) mkString ", "



\end{lstlisting}
\begin{lstlisting}
val l = List(1,2,3) 
l filter (i %$\Rightarrow$% {
  val %\bluebox{x}% = i %\%% 2 
  %\bluebox{x}%== 0
}) mkString ", "
\end{lstlisting}
\end{multicols}

\subsection{Implementation Details}

On the first glance, extracting a local variable seems to be trivial, but when braces are missing, the source generation has to work hard to create them where necessary. An additional difficulty coming from Scala's AST is that \src{Block} trees around a scope are only created when there are multiple statements present. To illustrate this, the following three listings show their respective AST.

\begin{multicols}{3}

\begin{lstlisting}
def m() = 42



\end{lstlisting}
\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_without_block.pdf}

\columnbreak

\begin{lstlisting}
def m() = { 
  42
}

\end{lstlisting}

\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_without_block.pdf}

\columnbreak

\begin{lstlisting}
def m() = { 
  42
  42
}
\end{lstlisting}

\begin{center}
  $\Downarrow$
\end{center}
\includegraphics[width=0.9\linewidth]{defdef_with_block.pdf}
\end{multicols}

We can see that the AST in the middle looks just like the first one, even though the literal is surrounded with curly braces. Adding a second statement obviously forces the parser to surround them with a \src{Block}. When we extract a local variable, the refactoring generates a surrounding \src{Block} tree if needed, and the source generators have then to figure out whether they need to print new curly braces.
\newpage
The Extract Local transformation is implemented as follows:

\begin{lstlisting}
val findInsertionPoint = predicate((t: Tree) %$\Rightarrow$% t == insertionPoint)

def replaceTree(from: Tree, to: Tree) = 
  topdown(matchingChildren(predicate((t: Tree) %$\Rightarrow$% t == from) &> constant(to)))

val insertNewVal = transform {

  case t @ CaseDef(_, _, NoBlock(body)) %$\Rightarrow$%
    t copy (body = mkBlock(newVal :: body :: Nil)) replaces t
    
  case t @ Try(NoBlock(block), _, _) %$\Rightarrow$%
    t copy (block = mkBlock(newVal :: block :: Nil)) replaces t
    
  case t @ DefDef(_, _, _, _, _, NoBlock(rhs)) %$\Rightarrow$%
    t copy (rhs = mkBlock(newVal :: rhs :: Nil)) replaces t
    
  %\ldots%
}

val extractLocal = 
  topdown(
    matchingChildren(
      findInsertionPoint &> 
      replaceTree(selectedExpression, extractedValueReference) &>
      insertNewVal))
\end{lstlisting}

The \src{findInsertionPoint} transformation acts as a simple predicate to find the insertion point in the AST. Next, \src{replaceTree} creates a transformation that replaces two trees by top-down traversal. The \src{insertNewVal} transformation then takes care of inserting the value, creating the necessary surrounding \src{Block} trees. Finally, the transformations are combined and applied using a top-down traversal strategy.

\subsection{Limitations}

Curly braces are not always placed ideally -- for example, the refactoring generates code like 

\begin{lstlisting}
(i %$\Rightarrow$% {
  %\ldots%
})
\end{lstlisting}

when it could just generate the code in the simpler form:
\needspace{3\baselineskip}
\begin{lstlisting}
{i %$\Rightarrow$%
  %\ldots%
}
\end{lstlisting}

\section{Inline Local}

The Inline Local -- also known as Inline Temp -- refactoring is the dual to Extract Local. It can be used to eliminate a local values by replacing all references to the local value by its right hand side.

Restricting the refactoring to \src{vals} only makes the refactoring easier to implement than its Java counterpart, where local variables can be reassigned. Still, inlining a local value can change the semantics of a program if the computation of the value has side-effects.

\figref{figure:inline-local-screenshot-1} shows a screenshot of the refactoring in the Scala IDE for Eclipse.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{inline_local_screenshot_1.png}
  \caption{The Inline Local refactoring lets us undo the extracted local refactoring from \figref{figure:extract-local-screenshot-1}.}
  \label{figure:inline-local-screenshot-1}
\end{figure}

\subsection{Examples}

Inlining a local value is in most cases trivial, but there are a few cases where it gets more complicated. Scala allows the programmer to omit the ''\src{.}`` when calling methods in certain cases:

\needspace{8\baselineskip}
\begin{lstlisting}
scala> Console println("Hello World")
Hello World

scala> List(1,2,3) filter (_ > 1)
res1: List[Int] = List(2, 3)

scala> 42 toString
res2: java.lang.String = 42
\end{lstlisting}

Things get more complicated when such calls are chained:

\begin{lstlisting}
scala> List(1,2,3) filter (_ > 1) partition (_ %\%% 2 == 0)
res3: (List[Int], List[Int]) = (List(2),List(3))

scala> 42 toString + " is the answer"
<console>:6: error: too many arguments for method toString: ()java.lang.String

scala> (42 toString) + " is the answer"
res5: java.lang.String = 42 is the answer
\end{lstlisting}

This means that when a value is inlined, it might become necessary to add parentheses around the inlined expression, as the following examples shows:

\begin{multicols}{2}
\begin{lstlisting}
class Extr2 {
  def m {
    %\bluebox{val five = 5 toString}%;
    println(five)
    five + " is the answer"
  }
}
\end{lstlisting}
\begin{lstlisting}
class Extr2 {
  def m {

    println(5 toString)
    (5 toString) + " is the answer"
  }
}
\end{lstlisting}
\end{multicols}

This is not done by the Inline Local implementation but by the source generator; another benefit that comes from separating the source generation from the refactorings.

\subsection{Implementation Details}

The Inline Local refactoring implementation is straight forward and is assembled from two transformations: one to remove the value and another one that replaces the references to the value with its original right hand side.

The implementation for the first transformation looks as follows:

\needspace{13\baselineskip}
\begin{lstlisting}
val removeSelectedValue = {
      
  def replaceSelectedValue(ts: List[Tree]) = {
    ts replaceSequence (List(selectedValue), Nil)
  }
  
  transform {
    case tpl @ Template(_, _, stats) if stats contains selectedValue =>
      tpl copy(body = replaceSelectedValue(stats)) replaces tpl
    case block @ BlockExtractor(stats) if stats contains selectedValue =>
      mkBlock(replaceSelectedValue(stats)) replaces block
  }
}
\end{lstlisting}

The selected value can either be contained in a block, or directly in a class template's body. To replace the reference, we first have to find out with what we want to replace it. If the value is bound to a method as follows:

\begin{lstlisting}
val inlineThis = someList filter _
\end{lstlisting}

We need the \src{\_} to be removed, this is why we cannot just take the value's right hand side. The replace transformation then simply replaces all trees that reference the value:

\begin{lstlisting}
val replaceReferenceWithRhs = {
      
  val references = index references selectedValue.symbol
  
  val replacement = selectedValue.rhs match {
    // inlining `list.filter _` should not include the `_`
    case Function(vparams, Apply(fun, args)) if vparams forall (_.symbol.isSynthetic) => fun
    case t => t
  }
  
  transform {
    case t if references contains t => replacement
  }
}
\end{lstlisting}

Combining these two transformations leads to the Inline Local refactoring:
\needspace{7\baselineskip}
\begin{lstlisting}
val inlineLocal = 
  topdown(
    matchingChildren(
      removeSelectedValue &> 
      topdown(
        matchingChildren(
          replaceReferenceWithRhs))))
\end{lstlisting}


\section{Extract Method}

Also among the most used refactorings by Java programmers is Extract Method. Extract Method is another key refactoring in making code more readable: if there is some code that can be grouped together, turn it into a method, and give it a meaningful name. The refactoring takes care of passing and returning the necessary parameters.

Martin Fowler once called Extract Method the refactoring's Rubicon \cite{FowlerRubicon}: 

\begin{quotation}
if you can do Extract Method, it probably means you can go on more refactorings [because it] requires some serious work. You have to analyze the method, find any temporary variables, then figure out what to do with them.
\end{quotation} 

\subsection{Features}

There exist several variations of the refactoring depending on how the selected code interacts with surrounding local variables. In the case where no local variables are used, the refactoring is trivial, we can just move the code into its own method and insert a call to it from its origin. 

When local variables are used, they need to be passed into the extracted method; the problematic case arises when local variables are re-assigned or declared inside and used outside of the extracted code. In this case, the respective variable has to be returned from the created method and the call to the created method becomes an assignment to the variable. 

In Java, this scheme works as long as no more than one variable requires such special treatment. In Scala, we are also restricted by a single return value, but in contrast to Java, Scala has tuples and syntactic sugar for tuple creation and deconstruction, as shown in \figref{figure:tuple-deconstruction}. This allows us to perform the refactoring in Scala where it would not (easily) be possible with similar code in Java.

\begin{figure}
\begin{lstlisting}
def parse(source: String): (Int, String) = {
  %\ldots%
  (intResult, restSource)
}

val (parsedInt, restSource) = parse("5$")
\end{lstlisting}

\caption{An example of Scala tuples. The function \src{parseInt} has the type \src{String $\Rightarrow$ (Int, String)}, which is syntactic sugar for \src{String $\Rightarrow$ Tuple2[Int, String]}. Line~3 shows how such a tuple can be returned; and the last line how it is deconstructed into the two variables \src{parsedInt} and \src{restSource}.}
\label{figure:tuple-deconstruction}
\end{figure}

Scala has other features like first class functions that allow variations of the refactoring, as described in \cite{ScalaRefactoring}. One more thing to mention is the choice of method placement: Scala allows methods to be defined inside other methods, which could also be an option for an Extract Method refactoring implementation.

\subsection{Implementation Details}

Extracting a method is done in several smaller steps:

\begin{description}
  \item[Create the Method] we want to extract. This includes determining all the inbound and outbound dependencies to construct the method signature.
  \item[Replace Extracted Statements] with a call to the newly created method. In case the method returns values, we have to assign them to new local values.
  \item[Insert the Method] somewhere in the surrounding class body.
\end{description}

The transformations that are used for Extract Method have already been described in Section~\vref{subsection:tree-transformations}. A screenshot of the refactoring can be seen in \figref{figure:extract-method-screenshot-1}.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{extract_method_screenshot_1.png}
  \caption{The Extract Method refactoring: starting with a text selection, the user has to provide a name for the extracted method. The proposed changes are displayed to the user and can then be applied.}
  \label{figure:extract-method-screenshot-1}
\end{figure}

\subsection{Examples}

To start, let us extract a statement that uses local variables and defines a variable that is used later in the program:

\needspace{6\baselineskip}
\begin{lstlisting}
def main(args: Array[String]) {
  println("Hello World!")
  //create a message:
   %\bluebox{val msg = args mkString ", "}%
  println(msg)
}
\end{lstlisting}

Applying the Extract Method refactoring results in a new method that takes an array as parameter and returns the created string.

\needspace{10\baselineskip}
\begin{lstlisting}
def main(args: Array[String]) {
  println("Hello World!")
  val msg = makeString(args)
  println(msg)
}
private def makeString(args: Array[String]): String = {
  //create a message:
  val msg = args mkString ", "
  msg
}
\end{lstlisting}

\subsubsection{Returning Multiple Values}

Using tuples to return values, we can return multiple values from an extracted method. The next two listings show an example:

\needspace{6\baselineskip}
\begin{lstlisting}    
def main(args: Array[String]) {
  val start =  0
  %\bluebox{val end   = 10}%
  %\bluebox{val sum = start to end reduceLeft ((x, y) => x + y)}%
  println("The sum from %\%%d to %\%%d is %\%%d".format(start, end, sum))
}
\end{lstlisting}

becomes

\needspace{10\baselineskip}
\begin{lstlisting}        
def main(args: Array[String]) {
  val start =  0
  val (end, sum) = calculateSum(start)
  println("The sum from %\%%d to %\%%d is %\%%d".format(start, end, sum))
}
private def calculateSum(start: Int): (Int, Int) = {
  val end   = 10
  val sum = start to end reduceLeft ((x, y) => x + y)
  (end, sum)
}
\end{lstlisting}

\subsubsection{Higher Order Functions}

Extract Method can also create a higher order function, as shown below:

\needspace{12\baselineskip}
\begin{lstlisting}  
def main() {
  
  val sumList: Seq[Int] => Int = _ reduceLeft (_+_)
  val prodList: Seq[Int] => Int = _ reduceLeft (_*_)
  
  val values = 1 to 10 toList
  
  %\bluebox{val     sum = sumList(values)   // the sum}%
  %\bluebox{val product = prodList(values)}%  // the product

  println("The sum from 1 to 10 is "+ sum +"; the product is "+ product)
}
\end{lstlisting}

We can now extract the calculation of the \src{sum} and the \src{product} values. Both values are returned because they are used later in the print statement (line breaks were added manually):

\needspace{17\baselineskip}
\begin{lstlisting}
def main() {
  
  val sumList: Seq[Int] => Int = _ reduceLeft (_+_)
  val prodList: Seq[Int] => Int = _ reduceLeft (_*_)
  
  val values = 1 to 10 toList
  val (sum, product) = sumAndProd(sumList, prodList, values)

  println("The sum from 1 to 10 is "+ sum +"; the product is "+ product)
}
private def sumAndProd(sumList: (Seq[Int]) => Int, 
                        prodList: (Seq[Int]) => Int, 
                        values: List[Int]): (Int, Int) = {
  val     sum = sumList(values)   // the sum
  val product = prodList(values)  // the product
  (sum, product)
}
\end{lstlisting}

\subsubsection{Arbitrary Expressions}

In our examples so far, we have only extracted statements from blocks. But we can also extract single expressions from within other expressions. The following example extracts the condition of an if-expression:

\needspace{8\baselineskip}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  
  if(%\bluebox{System.getProperties.get("os.name") == "Linux"}%) {
    println("We're on Linux!")
  }
}
\end{lstlisting}
\needspace{11\baselineskip}
\begin{lstlisting}
def main(args: Array[String]) {

  println("Detecting OS..")
  
  if(isLinux) {
    println("We're on Linux!")
  }
}
private def isLinux: Boolean = {
  System.getProperties.get("os.name") == "Linux"
}
\end{lstlisting}

\subsection{Limitations}

\begin{figure}
  \centering
  \includegraphics[width=0.6\linewidth]{extract_method_java_screenshot_1.png}
  \caption{Eclipse JDT's Extract Method Refactoring can be highly customized.}
  \label{figure:extract-method-java-screenshot-1}
\end{figure}


Compared to Eclipse's Extract Method for Java (see \figref{figure:extract-method-java-screenshot-1}), our version offers far less features -- for example, one cannot reorder the parameters, nor rename them. Allowing the user to choose where the extracted method should be placed also has not been implemented yet, and the visibility of the extracted method is always set to private.

Also, the generated code is not always as simple as it could be. Consider the following example:

\needspace{5\baselineskip}
\begin{lstlisting}
private def makeString(args: Array[String]): String = {
  //create a message:
  val msg = args mkString ", "
  msg
}
\end{lstlisting}

The local value \src{msg} could be inlined to get this simplified extracted method:

\needspace{5\baselineskip}
\begin{lstlisting}
private def makeString(args: Array[String]): String = {
  //create a message:
  args mkString ", "

}
\end{lstlisting}

\label{end-chapter:implemented-refactorings}

\emptypage

\chapter{Tool Integration} \label{chapter:tool-integration}

In this chapter, we are going to look at how the implemented refactorings can be integrated into other software and how the current integration into the Scala IDE for Eclipse looks like.

\section{Dependencies}

The refactoring library depends only on the Scala compiler -- no third party libraries are used. But it also does not contain any user interface; for a seamless integration, this needs to be implemented by the integrating tool.

For a performant integration into IDEs, the refactoring implementations do not instantiate their own compiler to parse and type check the code. This is typically already being done by the IDE and would only lead to duplicate effort and significantly slow down the refactoring process.

To access the compilation units of a project, the \src{Refactoring} trait -- from which all implementations inherit -- has an abstract member of a compiler instance:

\begin{lstlisting}
trait Refactoring extends %\ldots% {
  val global: scala.tools.nsc.interactive.Global
  %\ldots% 
}
\end{lstlisting}

To instantiate a refactoring implementation, a reference to the compiler needs to be provided. How this is done for the automated tests is described in Chapter~\vref{chapter:testing}.

As explained at the beginning of Chapter~\vref{chapter:implemented-refactorings}, a refactoring is performed in several steps; \figref{figure:refactoring-sequence} visualizes the interaction between the user, the IDE and the refactoring library. The prepare and perform methods as well as the required parameters are part of the \src{MutliStageRefactoring} abstract class (see \figref{figure:package-layout}).

\begin{figure}
  \centering
  \includegraphics[width=0.9\linewidth]{refactoring-sequence.pdf}
  \caption{The simplified (error conditions are not shown) interaction that happens when a refactoring is called.}
  \label{figure:refactoring-sequence}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.5\linewidth]{package-layout.png}
  \caption{The package layout of the library, showing the base classes and the implemented refactorings.}
  \label{figure:package-layout}
\end{figure}

\section{Integrating the Library}

\begin{figure}
  \centering
  \includegraphics[width=0.7\linewidth]{refactoring-editor.png}
  \caption{The Refactoring Editor: A simple Swing editor that can open files and invoke the refactorings.}
  \label{figure:refactoring-editor}
\end{figure}

How the refactorings can be integrated will be shown with a concrete example: the Refactoring Editor shown in \figref{figure:refactoring-editor}. We show the detailed instructions for the \src{Rename} refactoring only, but others can be integrated analog. The following code is all performed in an action listener. First we have to instantiate the refactoring:

\begin{lstlisting}
val refactoring = new Rename with CompilerProvider with GlobalIndexes {
  val ast = treeFrom(editor.getText)
  val index = GlobalIndex(ast)
}
\end{lstlisting}

The compiler in this example is provided by the \src{CompilerProvider} trait, which also offers the \src{treeFrom} method to turn a \src{String} into a \src{Tree} instance. We need to do this ourselves because our editor does not already parse the code, which would likely be different if we were to integrate the refactorings into a real IDE.

The Rename refactoring further needs an index of the whole program; we mix in the \src{GlobalIndexes} trait that allows us to construct an index from the AST (more on the index can be found in Section~\vref{section:analysis}).

Most of the refactorings need a selection to work. The \src{Selection} trait is implemented in two variations: \src{FileSelection} and \src{TreeSelection}. Depending on where the selection comes from, one or the other is easier to use. We create a \src{FileSelection} from the editor widget's selection:

\begin{lstlisting}
val selection: refactoring.Selection = {
  val file = refactoring.ast.pos.source.file
  val from = editor.getSelectionStart
  val to = editor.getSelectionEnd
  new refactoring.FileSelection(file, from, to)
}
\end{lstlisting}

Having a selection, we can now invoke the first refactoring step: the \src{prepare} method. Calling \src{prepare} returns \src{Either[PreparationError, PreparationResult]}, so we have to extract the result, or abort if an error occurred (a typical error cause for the Rename refactoring is an unsuitable selection).



\begin{lstlisting}
val preparationResult = refactoring.prepare(selection) match {
  case Left(refactoring.PreparationError(error)) => 
    showError(error)
    return
  case Right(r) => r
}
\end{lstlisting}

The preparation result's concrete type depends on the chosen refactoring. In the case of Rename, it simply contains the tree that we want to rename. Now to perform the refactoring, we need to pass the required parameters -- the new name. The \src{askName} function of our editor opens a dialog to enter a new name.

\needspace{6\baselineskip}
\begin{lstlisting}
val refactoringParameters = {
  val selectedName = preparationResult.selectedTree.symbol.nameString
  askNewName(selectedName)
}
\end{lstlisting}

Performing the refactoring is very similar to preparing it, except that we pass more parameters and get back a list of changes on success:

\begin{lstlisting}
val changes: List[Change] = 
  refactoring.perform(selection, preparationResult, refactoringParameters) match {
    case Left(refactoring.RefactoringError(error)) => 
      showError(error)
      return
    case Right(r) => r
  }
\end{lstlisting}

In our editor, we simply apply the changes to the file, using the \src{Change.applyChanges} method. In a real editor, the user should get a chance to see the proposed changes before they are applied.

This is all that is needed to integrate the refactorings into an IDE or other editor. Most refactorings are even simpler than rename and need no configuration at all -- for example, Organize Imports or Inline Local.

Next we shall see how the refactorings have been integrated with Eclipse and the Scala IDE for Eclipse.

\section{Scala IDE for Eclipse Integration}

The Eclipse integration is of course more complex than our previous example with the Refactoring Editor. Eclipse's Java Development Tools provides a rich set of refactorings; the core of this -- the Eclipse Language Toolkit \cite{LTK} -- can be used independently of the JDT and provides common functionality -- for example, wizards that guide the user through the refactoring process, edit and change objects that represent the refactoring's outcome, a viewer to visualize the patch. The LTK also takes care of applying the changes to the source code and undo management. 

\subsection{Integrating with Eclipse LTK}

We will now take a look at how the Refactoring library has been integrated into the Scala IDE for Eclipse. The diagram in \figref{figure:eclipse-integration} gives on overview over the main classes. 

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{eclipse-integration.pdf}
  \caption{An overview over the integration in the Scala IDE for Eclipse; the classes that are not in boxes are part of the Scala IDE integration. The classes with ellipsis stand for the other refactorings that are implemented in the same way.}
  \label{figure:eclipse-integration}
\end{figure}

\begin{description}
  \item[ActionAdapter] unifies and simplifies the integration into Eclipse's menu bar and context menus. It provides default implementations for unused methods.
  
  \item[RefactoringAction] is the abstract driver of a refactoring execution: it is the entry point when a refactoring is executed and manages the wizards.

  \item[ScalaIdeRefactoring] serves as a bridge between the LTK and a refactoring in the library; it connects the LTK's refactoring with the library's refactorings by creating the change objects for Eclipse (these are not the same as the \src{Change} objects in the library) and checks the initial and final conditions of a refactoring, i.e. it displays the errors that can be returned by \src{prepare} and \src{perform}.
  
  \item[ScalaRefactoringWizard] wraps the \src{ScalaIdeRefactoring} in a wizard and adds pages -- for example, one page contains an input field for a new name -- from the refactoring to the wizard.
    
  \item[RenameAction] implements the \src{RefactoringAction} and contains all refactoring specific code. It instantiates the corresponding IDE refactoring -- \src{RenameScalaIdeRefactoring} -- and provides it to the generic \src{RefactoringAction}. The other refactorings are implemented analog by their respective actions.
  
  \item[RenameScalaIdeRefactoring] Adapts the Rename Refactoring from the library to the \src{ScalaIdeRefactoring} interface. An example of the \src{ExtractMethodScalaIdeRefactoring} will be shown later.
\end{description}

All these actions are hooked up to the Eclipse menus in the Scala IDE's \src{plugin.xml}.

Another member of the IDE integration is \src{EditorHelpers}. It contains additional methods that adapt some of the often used Eclipse resources to be more Scala friendly -- working with \src{Option} instead of \src{null} and higher order utility functions:

\begin{lstlisting}
object EditorHelpers {

  def activeWorkbenchWindow: Option[IWorkbenchWindow] = %\ldots%

  def activePage(w: IWorkbenchWindow): Option[IWorkbenchPage] = %\ldots%

  def activeEditor(p: IWorkbenchPage): Option[IEditorPart] = %\ldots%

  def textEditor(e: IEditorPart): Option[ScalaSourceFileEditor] = %\ldots%

  def withCurrentEditor[T](block: ScalaSourceFileEditor => Option[T]): Option[T] = %\ldots%

  def withCurrentScalaSourceFile[T](block: ScalaSourceFile => T): Option[T] = %\ldots%
}
\end{lstlisting}

\subsection{Interfacing with the Scala IDE}

As we have mentioned several times, the refactoring library needs to be given an instance of the compiler. In the Scala IDE integration, the compiler can be accessed through the \src{ScalaSourceFile}, which mixes in the \src{ScalaCompilationUnit} trait that offers the following method:

\begin{lstlisting}
trait ScalaCompilationUnit extends %\ldots%
  def withCompilerResult[T](op: ScalaPresentationCompiler.CompilerResultHolder => T): T
  %\ldots%
}
object ScalaPresentationCompiler {
  
  trait CompilerResultHolder {
    val compiler : ScalaPresentationCompiler
    val sourceFile : SourceFile
    val body : compiler.Tree
    val problems : List[IProblem]
  }
  %\ldots%
}
\end{lstlisting}

This gives us access to the underlying compiler and the parsed and type-checked tree. In the integration code, this can then be used as follows:

\begin{lstlisting}
file withCompilerResult(crh =>  %\ldots%)
\end{lstlisting}

\subsection{A Concrete Example}

To wrap up this chapter, let us take a look at a  concrete \src{ScalaIdeRefactoring} and \src{RefactoringAction} implementation. The \src{ExtractMethodAction} inherits from the \src{RefactoringAction} template method and has to implement the \src{createRefactoring} method which returns a \src{ScalaIdeRefactoring} instance:

\begin{lstlisting}
class ExtractMethodAction extends RefactoringAction {
  def createRefactoring(start: Int, end: Int, file: ScalaSourceFile) = 
    Some(new ExtractMethodScalaIdeRefactoring(start, end, file))
}
\end{lstlisting}

The \src{ExtractMethodScalaIdeRefactoring} class then adapts the library's Extract Method refactoring implementation. All the non-refactoring specific code, like calling \src{perform}, is done in \src{ScalaIdeRefactoring}.

\newpage
\begin{lstlisting}
class ExtractMethodScalaIdeRefactoring(start: Int, end: Int, file: ScalaSourceFile) 
    extends ScalaIdeRefactoring("Extract Method") {
  
  var name = ""
  
  val refactoring = file withCompilerResult { crh => 
    new ExtractMethod with GlobalIndexes with NameValidation {
      val global = crh.compiler
      val index = GlobalIndex(global.unitOfFile(crh.sourceFile.file).body)
    }
  }

  lazy val selection = createSelection(file, start, end)

  def initialCheck = refactoring.prepare(selection)
  
  def refactoringParameters = name
  
  override def getPages = 
    new NewNameWizardPage(
      s => name = s, 
      refactoring.isValidIdentifier, 
      defaultName = "extractedMethod",
      helpId = "refactoring_extract_method") :: Nil 
}
\end{lstlisting}

The \src{NewNameWizardPage} is an SWT page that asks the user for a new name (see \figref{figure:extract-local-screenshot-1} for a screenshot). The closure passed as the first parameter is called whenever the name changes, so we can update our reference. The second parameter is a function of type $String \Rightarrow Boolean$ which is used to validate the entered name. Our name-updating closure is only called when the name passes the validation. There is also a default name for the extracted method's name and a \src{helpId} parameter that is used to hook up the online help with this wizard.

The actions for refactorings that use the inline mode -- Extract Local and Rename (Local) -- override some of the \src{ScalaIdeRefactoring}'s methods to bypass the wizard and set up the linked mode user interface directly.

\subsection{Adding New Refactorings}

Integrating a new refactoring with the Scala Eclipse plug-in can be done in three steps:

\begin{enumerate}
  \item Subclass \src{ScalaIdeRefactoring} and implement the necessary methods, analog to the existing IDE refactoring implementations. Organize Imports can serve as an example for a refactoring that does not need any configuration. If configuration is necessary, Extract Method or Rename can be the adapted.
  \item Create a \src{RefactoringAction} subclass that instantiates the previously created IDE refactoring.
  \item Add the new \src{RefactoringAction} to the plugin xml. The current implementations also show how shortcuts can be registered.
\end{enumerate}

With the existing refactoring implementations as a guideline, adding a new refactoring to the Scala IDE for Eclipse should be trivial.

\label{end-chapter:tool-integration}

\chapter{Testing} \label{chapter:testing}

The necessity of automated testing in modern software projects bears no repetition. Especially with a project that is so intrinsically dependent on another component -- the Scala compiler -- and its internals, having a strong suite of integration tests is essential. 

The following chapter shows how the refactoring integration tests are implemented with the goal to provide a guide for creating new tests.

\section{Compiling Test Code}

When the refactoring implementations are used, the IDE or more generally the invoking tool provides access to the compiler. The refactoring themselves do not posses the ability to analyze the code. In the tests, we therefore also have to provide a compiler that parses and type-checks our test code.

Because instantiating and initializing the compiler is a rather expensive operation compared to running a single test, one compiler instance is shared among all the tests. The \src{CompilerProvider} trait shown below gives access to this instance and includes functionality to turn a string into a fully typed \src{Tree} instance and to add a file in the form of a string to the compiler:

\begin{lstlisting}
trait TreeCreationMethods {
  
  val global: Global
    
  def treeFrom(src: String): global.Tree = %\ldots%
  
  def addToCompiler(name: String, src: String): AbstractFile = %\ldots%
}

trait CompilerProvider extends TreeCreationMethods {

  val global = CompilerInstance.compiler
}
\end{lstlisting}

Sharing a compiler instance is not without problems: because all the compilation units end up in the same compiler, this might result in conflicts. But this can easily be avoided by putting the individual test cases into their own package.

\section{Creating a Project Layout}

Now that we have a compiler, we need a way for our tests to represent Scala source files and combine them to a project-like structure. Thanks to Scala's support for raw strings, we can embed the Scala test code directly in our test cases and do not have to store them in external files or concatenate strings together. So in our test cases we can construct an AST from a string like this:

\begin{lstlisting}
val tree: global.Tree = treeFrom("""
  object Main {
    def main(args: Array[String]) {
      println("Hello World!")
    }
  }
""")
\end{lstlisting}

The \src{FileSet} class can be used to represent a Scala test project. It has an implicit conversion (see Appendix \vref{section:implicit-conversions}) method that adds the \src{becomes} method to \src{String} so it can be used as follows:

\begin{lstlisting}
val project = new FileSet {
  """
    Content of this source file.
  """ becomes
  """
    Expected test result for this file.
  """;

  "a second source file" becomes " %\ldots% "
}
\end{lstlisting}

The \src{FileSet} class also contains a method \src{applyRefactoring} that takes a function of type $FileSet \Rightarrow List[Change]$ which \src{FileSet} uses to turn itself into a list of changes. The list of changes is then applied to the sources and their result compared to the expected results (the parameter to \src{becomes}) using the standard JUnit asserts.

\src{FileSet} class is a member of \src{TestHelper}, which extends the \src{Refactoring} trait with the compiler provider and contains some test related helper functions:

\needspace{6\baselineskip}
\begin{lstlisting}
trait TestHelper extends Refactoring with CompilerProvider {
  abstract class FileSet(val name: String) {
    %\ldots%
  }
  def findMarkedNodes(src: String, tree: global.Tree): Option[FileSelection] = %\ldots%
}
\end{lstlisting}


\section{Implementation}

Taking a look at a test for the \src{Organize Imports} refactoring, the result looks as follows:
\needspace{15\baselineskip}
\begin{lstlisting}
@Test
def sortImportsByName = new FileSet {
  """
    import scala.collection.mutable.ListBuffer
    import java.lang.Object

    object Main
  """ becomes
  """
    import java.lang.Object
    import scala.collection.mutable.ListBuffer

    object Main
  """
} applyRefactoring %\textbf{organize}%
\end{lstlisting}

The \src{organize} function simply instantiates the concrete refactoring and performs it, returning the list of changes the refactoring generated. Organize Imports is a very simple refactoring because it needs neither a selection from the user nor any other configuration. A test case for the Rename refactoring can be seen in the following listing:

\begin{lstlisting}
@Test
def renameSelfType = new FileSet {
  """
  trait /*(*/T1/*)*/

  trait T3 {
    self: T1 %$\Rightarrow$%

  }""" becomes
  """
  trait /*(*/Trait/*)*/

  trait T3 {
    self: Trait %$\Rightarrow$%

  }"""
} applyRefactoring %\textbf{renameTo}%("Trait")
\end{lstlisting}

The selection is indicated by the two comments \src{/*(*/} and \src{/*)*/}. The comments remain in the source code, this is why we also see them in the expected result. 

Now we also need a way to pass the new method's name. With the help of Scala's multiple argument lists and partial application of functions, the \src{renameTo} function can be implemented like this:

\begin{lstlisting}
def renameTo(name: String)(pro: FileSet): List[Change] = %\ldots%
\end{lstlisting}

Now the first argument -- the new name -- is applied during the test setup, and the resulting function is then passed to the \src{applyRefactoring} just like before.

\label{end-chapter:testing}

\chapter{Conclusion} \label{chapter:outlook}

In this chapter, we shall review the results of this thesis and take a look at different ways the project could be continued.

\section{Accomplishments}

This thesis explored how Scala programmers can be supported with automated refactoring tools. The following achievements are worth being pointed out: 

\begin{itemize}
  \item We built an IDE independent refactoring library and integrated it into the Scala IDE for Eclipse. The library only depends on the Scala compiler and can thus be easily integrated into other IDEs and tools that manipulate Scala source code. Because the whole interaction and integration is handled by the IDE, the user does not notice that the refactorings are performed by a library. The library is currently used by the Scala IDE for Eclipse \cite{EclipseScalaIDE} and the integration is planned for the Emacs based ENSIME Scala IDE \cite{Ensime}.

  \item The following refactorings have been implemented so far: Rename, Extract Method, Extract Local, Inline Local, and Organize Imports.

  \item Creating a new refactoring does not require intimate knowledge of all parts of the library. The main task when writing a new refactoring is creating a transformation that can be applied to the Scala abstract syntax tree. To analyze the program, and index of the program symbols can be built an queried. The different parts of the library can also be used for other code manipulation tasks. For example, one project \cite{RichardEmberson} that manipulates Scala ASTs  is using the library's code generation to turn these manipulations back into source code.

  \item Refactoring transformations can easily be composed from and combined with other transformations. This allows us to build refactoring transformations from simpler, more fundamental transformations. Several different strategies can be used to apply transformations to the program.

  \item Code generation is completely hidden from the refactoring implementor. Code generation automatically detects changes in the AST and generates the code while retaining the existing formatting and comments.
\end{itemize}

The integration into the Scala IDE for Eclipse and other integrations coming up seem to indicate that the project was a success and that it is feasible to create refactoring infrastructure that is IDE independent and can be shared by several projects.

\section{Future Work}

The results of this thesis could be continued in various ways:

\begin{itemize}
  \item Creating new refactorings benefits all the IDEs that integrate the library. At the moment, only a handful of refactorings have been implemented, but a lot of work has been spent on the underlying library components. It would be interesting to see if larger refactorings can be built from the implemented simple refactoring transformations. For example, renaming the parameters during Extract Method could be implemented by applying the rename transformation to the extracted method. There are other refactorings that build on simpler ones: Form Template Method uses Extract Method. For a more detailed list, see \cite{Refactor}.

  \item One could also take the idea of user created refactorings one step further and create a graphical representation of the transformations and let the user assemble and apply them to his code. This feature could take inspiration from IntelliJ IDEA's Structural Search and Replace \cite{SSR}.

  \item Instead of creating new refactoring implementations, the existing ones could be integrated into other IDEs. For example, the NetBeans based IDE \cite{NetBeansJScalaIDE} also uses the Scala compiler, so an integration should easily be possible.

  \item The existing IDE integration could be enhanced. For example, by cross language refactorings, so that a rename in Scala would also rename the necessary Java parts of the program (see e.g. \cite{EclipseCrossLanguageRefactoring}). Alternatively, the existing integration could be improved. For example by giving the refactoring user more configuration possibilities.

  \item Not directly a continuation of this project but also interesting would be to study refactorings from functional programming languages and port them to Scala, implemented using this library. 
\end{itemize}

These ideas all assume that the library in its current state is feature complete and free of bugs, which is unlikely. So whatever course is taken, the library itself will also need to be enhanced. 

\section{Acknowledgments}

First I would like to thank my supervisor, Professor Peter Sommerlad, for his support during the thesis and for giving me a free hand in realizing my own ideas. Our weekly meetings ensured that I stayed on track and helped me manage this huge project.

Many thanks also to Miles Sabin who was always there to help me when I had any trouble with the Scala IDE and for supporting me from the beginning.

Robin Stocker and Miguel Garcia provided insightful comments on my documentation, thank you!

Many thanks to everyone from the Scala team and in the Scala community who encouraged me and provided feedback. 

A special thanks goes to Richard Emberson who uncovered many bugs in the implementation and always patiently waited for a fix.

\label{end-chapter:outlook}

\appendix

\emptypage

\chapter{Project Environment} \label{chapter:project-environment}

The project's website is located at \url{http://www.scala-refactoring.org}. The Git repository, wiki and issue tracker are all hosted by \textit{Assembla} and can be reached from the website. The Scala IDE for Eclipse is located at \url{http://www.scala-ide.org}.

The library is also published to the Scala community's central Maven repository on \url{http://www.scala-tools.org}, under the \src{org.scala-refactoring} group and the  \src{org.scala-refactoring.library} artifact identifier.

\section{Tools}

The following tools were used to manage and produce the almost 15'000 lines of code (including the documentation) the project contains:

\begin{description}
  \item[Scala IDE for Eclipse] is an obvious choice. A custom build was used that included the refactoring integration until it was included in the main distribution.
  \item[Eclipse Galileo] with the \textbf{Vi} plug-in.
  \item[Git] to manage the source code of the various projects and to connect to EPFL's \textbf{Subversion} repository.
  \item[Maven and Tycho] to manage the build process, which was a huge improvement compared to the older \textbf{Ant} based build.
  \item[Hudson] continuously built the project and creates update-sites for the builds.
  \item[Trac] was initially used on the project server before everything was moved to an \textbf{Assembla} space.
  \item[\LaTeXe] to create this document, along with KDE's \textbf{Kile} editor.
  \item[Inkscape and Graphviz] to create all the graphics.
\end{description}

\section{Time Report}

The mandatory work load for this thesis was 810 hours; distributed over the 21 weeks, this is about 39 hours per week. The actual time was a bit higher, around 850 hours, distributed over the 21 weeks as follows:

\begin{center}
  \includegraphics[width=\linewidth]{time.pdf}
\end{center}


\section{Project Plan}

The two project plans on the following two pages show the originally planned and the actual work that has been done. A few comments on these plans:

\begin{itemize}
  \item The original plan did not cover the whole project duration, instead it was agreed that we would assess the situation after half of the project's duration to determine the direction for the second half. 
  \item During the project, we noticed that the original plan was too ambitious, so many planned implementations could not be done. Instead, the whole source generation part had to be rewritten (see \vref{subsection:comparison-with-the-term-project} for more details on why this was necessary).
  \item The original plan contained the Scala IDE integration as one of the first tasks, but this was subsequently moved to the end because of some larger restructurings in the Scala IDE (switch to a new build system). All implemented refactorings are now part of the nightly build and are going to be included in the next release.
\end{itemize}



\newpage
\thispagestyle{empty}
\enlargethispage{5cm}
\begin{center}
  \includegraphics[width=1.7\linewidth,angle=90]{project_plan_1.pdf}
\end{center}

\newpage
\thispagestyle{empty}
\enlargethispage{5cm}
\begin{center}
  \includegraphics[width=1.7\linewidth,angle=90]{project_plan_2.pdf}

\label{end-chapter:project-environment}
\end{center}


\chapter{User Guide} \label{chapter:user-guide}

This appendix describes the implemented refactorings from the user's perspective. We show how the refactorings can be invoked, what features and limitations they have.

The refactorings are all accessible from the Refactoring menu and with various shortcuts:

\begin{center}
  \includegraphics[width=0.6\linewidth]{refactoring-menu-screenshot.png}
\end{center}

The contents of this user guide are also included in the Scala IDE for Eclipse's online help.

\section{Rename}

The Rename refactoring can be used to rename all names defined in a Scala program. This includes for example: methods, classes, objects, local variables, method parameters, type parameters. To perform the refactoring, the name has to be selected -- placing the cursor on the name also suffices -- and then the refactoring can be invoked.

If the name that is renamed is only accessible in the source file -- for example, a local variable, or a method inside another method -- then the refactoring is invoked in the inline mode, which links all occurrences in the source file and changes them as you type:

\begin{center}
  \includegraphics[width=0.5\linewidth]{rename_screenshot_3.png}
\end{center}

If the name is accessible from other source files, the renaming is done in the wizard and the changes can be previewed:

\begin{center}
  \includegraphics[width=\linewidth]{rename_screenshot_2.png}
\end{center}

When the new name is entered in the wizard, it is checked if the name is valid and not already in use.

\subsection{Limitations}

When renaming a top-level type in a file where the source file has the same name as the type, the file is currently not renamed. 

Scala 2.8 introduced named parameters, but because of how they are represented internally, they are not being renamed at the moment, leading to compile errors.

\section{Organize Imports}

Organize Imports cleans up the import statements in the current file. It does however not remove any unused imports nor imports that are needed for the program to compile. The refactoring does the following to the imports:

\begin{description}
  \item[Sorts] the statements alphabetically by their full name.
  \item[Collapses] multiple distinct imports from the same package into a single statement.
  \item[Simplifies] the imports: when a wildcard imports the whole package content, individual import from that package are removed, unless they contain renames.
\end{description}

The following screenshot shows the changes Organize Imports proposes:

\begin{center}
  \includegraphics[width=\linewidth]{organize_screenshot_1.png}
\end{center}

\subsection{Limitations}

The current implementation has some limitations compared to its Java counterpart. The refactoring does not do any dependency analysis, imports that are missing are not added, and unneeded imports are not being removed by Organize Imports. 

\section{Extract Local}

Extract Local allows you to introduce a new local variable from an expression: the value is initialized with the selected expression and the original  expression is replaced with a reference to the new value. 

The refactoring is also known as Introduce Explaining Variable, because it allows the programmer to simplify long expressions by splitting them into several smaller ones and making the code more readable. 

Selecting an expression like in the following screenshot:

\begin{center}
  \includegraphics[width=0.8\linewidth]{extract_local_screenshot_2.png}
\end{center}

and then executing the refactoring creates a new local variable and lets you change the name in Eclipse's linked mode:

\begin{center}
  \includegraphics[width=0.8\linewidth]{extract_local_screenshot_3.png}
\end{center}

Extracting new local values can also be useful for debugging to see the intermediate results of a computation.

\section{Inline Local}

The Inline Local refactoring lets you remove unneeded local values. Selecting a value and invoking the refactoring will replace all references to the value with the value's right hand side.

Note that when there are side-effects in the evaluation of the value, the refactoring might change you program's behavior. Only local \src{vals} can be inlined, \src{vars} are not supported.

The following screenshot shows the refactoring in action:

\begin{center}
  \includegraphics[width=\linewidth]{inline_local_screenshot_1.png}
\end{center}

\section{Extract Method}

The Extract Method refactoring lets you extract one or many expressions into a new private method. The refactoring takes care of passing all necessary parameters to the method and returns all values that are needed.

To invoke the refactoring, a selection inside of a method has to be made. The refactoring wizard will then ask for a new name and show a preview of the changes:

\begin{center}
  \includegraphics[width=\linewidth]{extract_method_screenshot_1.png}
\end{center}

\subsection{Limitations}

Compared to Eclipse's Extract Method for Java, the Scala version currently lacks many features -- for example, one cannot reorder the parameters, nor rename them. Allowing the user to choose where the extracted method should be placed also has not been implemented yet, and the visibility of the extracted method is always set to private.

\label{end-chapter:user-guide}

\chapter{Developer How-To} \label{chapter:developer-how-to}

This appendix provides an introduction for developers that are interested in developing new refactorings. We will create a new refactoring step-by-step and point to the relevant sections in the main documentation for details and background information. 

%Why should anybody want to write a refactoring? IDEs usually provide a variety of general refactorings and code generators, but maybe a framework or project specific automated refactoring that no IDE offers would be helpful. 

Before we start, we should clarify that when we write about \textit{refactoring}, this includes all program transformations that affect the source code, so a transformation that just creates new code -- e.g. adds a method to a class -- can be implemented as well.

\section{Introduction}

A refactoring is essentially a transformation of the program in its abstract syntax tree form. Because our Scala programs are stored in plain text files, the transformed syntax tree has to be converted back to text -- and this without losing all our pretty formatting. 

One of the design goals of the Scala Refactoring library was to separate these two concerns as good as possible, so that the implementor of a refactoring can concentrate on transforming trees and let the library handle all the code generation for him (for more information on how the code generation works, see Section~\vref{section:source-generation}). 

To make it easier for those who already know the Scala compiler's abstract syntax tree (AST), the refactorings are completely based on this AST instead of introducing a new program representation (the Scala AST is documented in Appendix~\vref{chapter:scala-ast}). 

\section{The Example}

In Scala, the compiler generates getters and setters for us; this is great for the common case where the value is just set or retrieved. If one needs to do more -- for example validate the new value, Scala allows to write explicit getters and setters. The following listing shows the original code:

\needspace{3\baselineskip}
\begin{lstlisting}
class Person(val name: String, var age: Int) {
  def debug = name +" is "+ age +" years old."
}
\end{lstlisting}

and the same with explicit getters and setters (remember that in Scala \src{person.age = 42} is the same as \src{person.age\_=(42)}):

\needspace{5\baselineskip}
\begin{lstlisting}
class Person(name: String, private var _age: Int) {
  def debug = name +" is "+ age +" years old."
  def age = _age
  def age_=(age: Int) = _age = age
}
\end{lstlisting}

Now let us automated this! In this example, we will concentrate on the refactoring implementation only; how the integration into the IDE or an other tool could look like is explained in Chapter~\vref{chapter:tool-integration}.

To keep our example as simple as possible, the refactoring will only take two parameters: a string that represents the source code and an integer for the current caret position -- that is, the selected value or variable for which the refactoring should create explicit getters and setters. The result of this operation is another string that represents the refactoring program. 

The refactoring will have to perform the following operations:

\begin{enumerate}
  \item Find out which value the user selected.
  \item Find the class that the selected value belongs to.
  \item Create a private field for the selected value.
  \item Create the getter and the setter. The setter is only needed when the selected value is mutable.
  \item Transform the AST to include the new methods and changed field.
  \item Turn the changed AST back into source code.
\end{enumerate}

\section{Implementing It}

Refactoring implementations subclass from \src{scala.tools.refactoring.Refactoring}, which has an abstract member \src{global: scala.tools.nsc.interactive.Global} -- an instance of the compiler that is typically provided by the IDE. Because we are not implementing this example in an IDE setting, we can mix in the \src{scala.tools.refactoring.util.CompilerProvider} trait which instantiates a compiler for us.

So far, our code looks as follows:

\begin{lstlisting}
class GenerateGettersAndSettersRefactoring(sourceCode: String, caretPosition: Int) 
    extends Refactoring with CompilerProvider {
  
  import global._
  
  def refactor(): String = { %\ldots% }
}
\end{lstlisting}

In the remainder of the example, we will complete the \src{refactor} method. The first thing we need to do is to turn the \src{sourceCode} string into an AST. The \src{treeFrom} method mixed in from \src{CompilerProvider} can do this:

\begin{lstlisting}
    val ast: Tree = treeFrom(sourceCode)
\end{lstlisting}

The \src{ast} value now holds a reference to the root element of the AST. Next we want a way to find out on which \src{val} (or \src{var}) the caret is positioned, and we need to know the corresponding template (the body of the class), where we later want to insert the getters and setters. From the source file and the caret position, we can create a \src{Selection} object which contains methods to find selected trees:
    
\begin{lstlisting}
    val selection = new FileSelection(ast.pos.source.file, caretPosition, caretPosition+1)
    
    val selectedValue = selection.findSelectedOfType[ValDef].getOrElse {
      return "No val/var selected."
    }
    
    val template = selection.findSelectedOfType[Template].getOrElse {
      return "No enclosing class found."
    }

    val createSetter = selectedValue.symbol.isMutable
\end{lstlisting}

Now that we know more about the selected value, we can start creating the new trees that we are going to insert into the AST. The new private field is created by prefixing the existing one with \src{\_}. We also need to adjust the modifiers of the field:

\begin{lstlisting}
    val privateName = "_"+ publicName
    
    val privateFieldMods = if(createSetter) {
      Modifiers(Flags.PARAMACCESSOR).
        withPosition (Flags.PRIVATE, NoPosition).
        withPosition (Tokens.VAR, NoPosition)
    } else {
      Modifiers(Flags.PARAMACCESSOR)
    }
      
    val privateField = selectedValue copy (mods = privateFieldMods, name = privateName)
\end{lstlisting}

The \src{withPosition} calls make sure that the field gets \src{private var} modifiers. Modifiers serve two purposes here: they describe the role of the tree -- {\src{PARAMACCESSOR} -- and the modifiers that need to be present in the source code -- \src{PRIVATE} and \src{VAR}.

The getter and setter trees are simple method definitions (see Appendix~\vref{chapter:scala-ast} for more information on the AST classes):

\begin{lstlisting}
    val getter = DefDef(
        mods = Modifiers(Flags.METHOD) withPosition (Flags.METHOD, NoPosition), 
        name = publicName, 
        tparams = Nil, 
        vparamss = List(Nil), 
        tpt = EmptyTree, 
        rhs = Block(
                Ident(privateName) :: Nil, EmptyTree))
    
    val setter = DefDef(
        mods = Modifiers(Flags.METHOD) withPosition (Flags.METHOD, NoPosition), 
        name = publicName +"_=",
        tparams = Nil,
        vparamss = List(List(ValDef(Modifiers(Flags.PARAM), publicName, 
                               TypeTree(selectedValue.tpt.tpe), EmptyTree))), 
        tpt = EmptyTree,
        rhs = Block(
                Assign(
                  Ident(privateName),
                  Ident(publicName)) :: Nil, EmptyTree))
\end{lstlisting}

The \src{vparamss} argument is a list of lists, because of Scala's multiple argument lists. Note that we use the selected value's type tree for the formal parameter's \src{ValDef}. In general, one does not have to specify any types in the modified trees except when they should be printed in the source code.

The \src{rhs} of the setter is simply an assignment with the private name on the left and the public name on the right. Both \src{rhs} are wrapped in a \src{Block} to make sure the source generator prints curly brackets around the method.

Now that we have all the trees, we need to insert them into our existing AST. Modifying ASTs is done with \textit{transformations} (see Section~\vref{section:transformation}). A transformation is basically a function that takes a tree and returns an \src{Option[Tree]}. This transformation is then applied to all trees in the AST. 
\newpage
The \src{transform} function creates a transformation from a partial function and is used as follows:

\begin{lstlisting}
    val insertGetterSettersTransformation = transform {
        
      // only apply the transformation to the selected template
      case tpl: Template if tpl == template => 
      
        // find the selected value in the class body and replace it with our privateField
        val classParameters = tpl.body.map { 
          case t: ValDef if t == selectedValue => privateField setPos t.pos
          case t => t 
        }
      
        // only create a setter when we have a `var`
        val body = if(createSetter)  
          getter :: setter :: classParameters
        else
          getter :: classParameters
        
        tpl.copy(body = body) setPos tpl.pos
    }
\end{lstlisting}

Note the \src{setPos} calls: Whenever a new tree should replace an existing one -- that is, be inserted at the same position and taking over the original tree's comments -- we give it the original tree's position.

We now have a generic transformation, but it has not been applied to our AST yet. There exist different strategies on how to do this, for our transformation we traverse the tree top-down (or pre-order) and try to apply \src{insertGetterSettersTransformation} to all subtrees. If the transformation can be applied, the modified tree replaces the original one; otherwise the original tree is retained.

\begin{lstlisting}
    val transformedAst = topdown(
                           matchingChildren(
                             insertGetterSettersTransformation)) apply ast
\end{lstlisting}
    
The AST can now be transformed into a list of change objects -- i.e a patch -- that can then be applied to the source code:

\begin{lstlisting}
    val changes = refactor(transformedAst.toList)
    
    Change.applyChanges(changes, sourceCode)
\end{lstlisting}

\section{The Result}

Applying the refactoring to both attributes of our original example:

\begin{lstlisting}
class Person(val name: String, var age: Int) {
  def debug = name +" is "+ age +" years old."
}
\end{lstlisting}

yields the following result:

\needspace{12\baselineskip}
\begin{lstlisting}
class Person(_name: String, private var _age: Int) {
  def age = {
    _age
  }
  def age_=(age: Int) = {
    _age = age
  }
  def name = {
    _name
  }
  def debug = name +" is "+ age +" years old."
}
\end{lstlisting}

This concludes our example of an automated refactoring implementation. All we had to do was to create some trees and write a transformation that applied our changes to the AST; turning the AST back into source code happened almost automatically.

The implementation of this refactoring can be found in the \src{implementations} package of the library. To see how other refactorings were implemented, continue reading Chapter~\vref{chapter:implemented-refactorings}. To learn more about the internals of the library, take a look at Chapter~\vref{chapter:refactoring-library}.

\label{end-chapter:developer-how-to}

\include{91_scala_ast}

\emptypage

\chapter{Advanced Scala Features} \label{chapter:advanced-scala-features}

This documentation does not contain an introduction to the Scala language, so an understanding of the basic concepts is assumed. This appendix explains some of the more advanced features and patterns of Scala that are used during the explanations in this thesis.

\section{Path Dependent Types} \label{section:path-dependent-types}

Path dependent types are best explained with an example (taken from Programming Scala \cite{ProgrammingScala}). We have an \src{Animal} class with an abstract type member called \src{SuitableFood} which is then defined in the subclasses to a suitable type.
\begin{lstlisting}
abstract class Food

abstract class Animal {
  type SuitableFood <: Food
  def eat(food: SuitableFood)
}

class Grass extends Food
class Cow extends Animal {
  type SuitableFood = Grass
  def eat(food: Grass) {}
}

class DogFood extends Food
class Dog extends Animal {
  type SuitableFood = DogFood
  def eat(food: DogFood) {}
}
\end{lstlisting}

This now prevents us from feeding the wrong kind of food to our animals:

\needspace{11\baselineskip}
\begin{lstlisting}
scala> val bessy = new Cow
bessy: Cow = Cow@3fb01949

scala> val lassie = new Dog
lassie: Dog = Dog@46c9220

scala> lassie eat (new bessy.SuitableFood)
<console>:14: error: type mismatch;
 found   : Grass
 required: DogFood
       lassie eat (new bessy.SuitableFood)
\end{lstlisting}

In the context of the Scala compiler, all instances of \src{Tree} are dependent on the compiler -- that is, impossible to mix trees from different compiler instances.

\begin{lstlisting}
trait Trees {
  %\ldots%
  abstract class Tree extends Product {
  %\ldots%
}
\end{lstlisting}

The Scala Refactoring library follows this design, all functionality that operates on compiler dependent types is in traits that have a compiler instance as an abstract member, like for example in the \src{AbstractPrinter} or the \src{Indexes}:

\begin{lstlisting}
trait AbstractPrinter {
  val global: scala.tools.nsc.interactive.Global
  import global._
  %\ldots%
}

trait Indexes {
  val global: scala.tools.nsc.interactive.Global
  %\ldots%
}
\end{lstlisting}

The user of the refactoring library then has to provide this abstract member and all implemented traits share the same instance. In the automated tests, this is done by the \src{CompilerProvider} trait.

\section{Stackable Traits} \label{section:stackable-traits}

Stackable traits are related to the decorator design pattern, except that they do not decorate objects at run-time but traits at compile-time. Let us take a look at an example. Assume that we have a trait that allows us to log events and an implementation that logs to the standard output:

\begin{lstlisting}
trait Logging {
  def log(severity: Int, msg: String): Unit
}

class ConsoleLogger extends Logging {
  def log(severity: Int, msg: String) = {
    println("%\%%d: %\%%s" format (severity, msg))
  }
}
\end{lstlisting}

Now we want to have a logger that only logs events of a certain severity, or one that filters the messages. We could subclass \src{ConsoleLogger}, but there are potentially many concrete loggers, and we want the user of the logger to be able to combine these features as he likes. This is where stackable traits are useful. Stackable traits use the \src{abstract override} modifier to override an abstract method and are allowed to call \src{super} in the implementation, even though the super method is not implemented.

\begin{lstlisting}
trait LogOnlyErrors extends Logging {
  abstract override def log(severity: Int, msg: String) {
    if(severity >= 3)
      super.log(severity, msg)
  }
}
\end{lstlisting}

When we instantiate a \src{new ConsoleLogger with LogOnlyErrors}, the abstract override method in \src{LogOnlyErrors} overrides the \src{log} method in \src{ConsoleLogger}. We can also create more such stackable traits and combine them.

\begin{lstlisting}
trait TreatAllAsErrors extends Logging {
  abstract override def log(severity: Int, msg: String) {
    super.log(3, msg)
  }
}
\end{lstlisting}

Because of Scala's trait linearization, the order of the stackable traits is significant and allows further combinations, as shown below.

\begin{lstlisting}
scala> val logger = new ConsoleLogger with TreatAllAsErrors with LogOnlyErrors  
logger: ConsoleLogger with TreatAllAsErrors with LogOnlyErrors = $anon$1@8aee908

scala> logger.log(1, "Something insignificant happened.")

scala> logger.log(4, "A critical error, severity 4!")
3: A critical error, severity 4!

scala> val logger2 = new ConsoleLogger with LogOnlyErrors with TreatAllAsErrors
logger2: ConsoleLogger with LogOnlyErrors with TreatAllAsErrors = $anon$1@2a788315

scala> logger2.log(1, "Something insignificant happened.")
3: Something insignificant happened.

scala> logger2.log(1, "A critical error, severity 4!")
3: A critical error, severity 4!
\end{lstlisting}

\section{Implicit Conversions} \label{section:implicit-conversions}

Implicit conversions (also known as the \textit{pimp my library} pattern) can be used to (seemingly) add new methods to an existing class. Assume that we are working with currencies and have a class to represent Swiss francs:

\begin{lstlisting}
class SwissFrancs(private val amount: Int) {
  def + (other: SwissFrancs) = new SwissFrancs(amount + other.amount)
  override def toString = "CHF "+ amount
}
\end{lstlisting}

Thanks to Scala's support for methods with operator names, we can add instances of Swiss francs using \src{+}, but we still have to construct them verbosely. With an implicit conversion, we can add a \src{francs} method to \src{Int} that makes for a very readable syntax:

\begin{lstlisting}
implicit def intToSwissFrancs(i: Int) = new Object { def francs = new SwissFrancs(i) }

scala> 5.francs + 10.francs
res1:  SwissFrancs = CHF 15
\end{lstlisting}

This is also how Scala enriches Java's built-in types or why we can form tuples from any two objects using $\rightarrow$:

\begin{lstlisting}
class ArrowAssoc[A](x: A) {
  %\ldots%
  def %$\rightarrow$% [B](y: B): Tuple2[A, B] = Tuple2(x, y)
}

implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] = new ArrowAssoc(x)

scala> "answer" %$\rightarrow$% 42
res2:  (java.lang.String, Int) = (answer,42)
\end{lstlisting}

\section{Self Type Annotation} \label{section:self-type-annotation}

Scala allows the programmer to specify an alias for \src{this} inside the current class. This is often useful to access the outer instance from an inner class where \src{this} is already bound to the inner class. 

\begin{lstlisting}
class OuterClass(val name: String) {
  outerclass =>

  class Inner {
    println("I'm the inner class of "+ outerclass.name)
  }
}
\end{lstlisting}

The self type annotation allows us to annotate this self type with additional types and are a way to describe dependencies the class or trait has. For example, if we have a class that uses some kind of service interface, we can specify the service interface with a self type annotation:

\begin{lstlisting}
trait Service {
  def callWebservice %\ldots%
}

class ServiceUser {
  self: Service =>

  callWebservice %\ldots%
}

val myService = new ServiceUser with SomeServiceImplementation
\end{lstlisting}

The user of \src{ServiceUser} then has to instantiate it with a suitable implementation of \src{Service} to make the program compile. In most cases, one could also just let \src{ServiceUser} inherit from \src{Service}, but using a self type annotation is conceptually clearer than inheritance.


\section{Package Nesting} \label{section:package-nesting}

It is a common misconception that Java supports nested packages; they are only nested in the file system, but the language itself has no notation of nested packages. In Scala on the other hand, packages can be nested. The following two listings represent different compilation units:

\needspace{4\baselineskip}
\begin{lstlisting}
package com.mycompany.project
package pd

class Student
\end{lstlisting}

\begin{lstlisting}
package com.mycompany.project
package ui

import pd.Student
\end{lstlisting}

Note how the import statement does not have to specify the fully qualified name but can simply import \src{pd.Student} because both compilation units are in the \src{com.mycompany. project} package.

\label{end-chapter:advanced-scala-features}

\chapter{License} \label{chapter:scala-license}

The project is licensed under the Scala license:

\begin{small}\begin{verbatim}

Copyright (c) 2002-2010 EPFL, Lausanne, unless otherwise specified.
All rights reserved.

This software was developed by the Programming Methods Laboratory of the
Swiss Federal Institute of Technology (EPFL), Lausanne, Switzerland.

Permission to use, copy, modify, and distribute this software in source
or binary form for any purpose with or without fee is hereby granted,
provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the EPFL nor the names of its contributors
      may be used to endorse or promote products derived from this
      software without specific prior written permission.


THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
\end{verbatim}                \end{small}

\emptypage
\clearpage
\bib

\end{document}


